### **FFmpegUI 后端开发文档**

**技术栈**: Python

---

### **第一部分：数据库结构设计**

#### **1. 用户表 (`users`)**

存储用户账户、认证信息和存储配额。

```sql
-- 用户表
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),  -- 用户唯一ID
    username VARCHAR(50) UNIQUE NOT NULL,           -- 用户名，唯一
    email VARCHAR(255) UNIQUE NOT NULL,             -- 邮箱，唯一，用于登录
    password_hash VARCHAR(255) NOT NULL,            -- 密码哈希（绝不存储明文！）
    storage_quota_bytes BIGINT NOT NULL DEFAULT 5368709120, -- 存储配额（默认5GB）
    storage_used_bytes BIGINT NOT NULL DEFAULT 0,    -- 已用存储空间
    last_login_at TIMESTAMPTZ,                      -- 最后登录时间（用于生命周期管理）
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),  -- 创建时间
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()   -- 最后更新时间
);

-- 为常用查询字段创建索引
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_last_login_at ON users(last_login_at);
```

#### **2. 文件表 (`files`)**

存储所有文件的元数据，是系统的核心表。

```sql
-- 文件表
CREATE TYPE file_status AS ENUM ('uploading', 'active', 'processing', 'completed', 'pending_deletion', 'deletion_failed');

CREATE TABLE files (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),  -- 文件唯一ID
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE, -- 所属用户ID（外键，级联删除）
    original_filename VARCHAR(255) NOT NULL,        -- 用户上传时的原始文件名
    stored_filename VARCHAR(255) NOT NULL,          -- 服务器上存储的唯一文件名（如UUID）
    file_path TEXT NOT NULL,                        -- 文件在存储系统中的完整路径
    file_size_bytes BIGINT NOT NULL,                -- 文件大小（字节）
    mime_type VARCHAR(100),                         -- 文件MIME类型
    status file_status NOT NULL DEFAULT 'active',   -- 文件状态
    is_pinned BOOLEAN NOT NULL DEFAULT FALSE,       -- 是否被置顶（受保护，不会被自动清理）
    last_accessed_at TIMESTAMPTZ NOT NULL DEFAULT NOW(), -- 最后访问时间（用于生命周期管理）
    deletion_scheduled_at TIMESTAMPTZ,              -- 被标记为待删除的时间
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),  -- 创建时间
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()   -- 最后更新时间
);

-- 创建索引以优化查询
CREATE INDEX idx_files_user_id ON files(user_id);
CREATE INDEX idx_files_status ON files(status);
CREATE INDEX idx_files_last_accessed_at ON files(last_accessed_at);
```

#### **3. 处理任务表 (`processing_tasks`)**

跟踪所有异步的 FFmpeg 处理任务。

```sql
-- 处理任务表
CREATE TYPE task_status AS ENUM ('pending', 'running', 'success', 'failure', 'cancelled');

CREATE TABLE processing_tasks (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),  -- 任务唯一ID
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE, -- 发起任务的用户ID
    source_file_ids JSONB NOT NULL,                  -- 源文件ID列表 ["uuid1", "uuid2"]
    output_filename VARCHAR(255) NOT NULL,           -- 用户期望的输出文件名
    operations JSONB NOT NULL,                       -- 处理操作步骤的JSON描述
    celery_task_id VARCHAR(255) UNIQUE,              -- 对应的Celery任务ID
    status task_status NOT NULL DEFAULT 'pending',   -- 任务状态
    progress INTEGER NOT NULL DEFAULT 0,             -- 处理进度 (0-100)
    result_file_id UUID REFERENCES files(id) ON DELETE SET NULL, -- 处理完成后生成的结果文件ID
    error_message TEXT,                              -- 失败时的错误信息
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),  -- 创建时间
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()   -- 最后更新时间
);

-- 创建索引
CREATE INDEX idx_processing_tasks_user_id ON processing_tasks(user_id);
CREATE INDEX idx_processing_tasks_celery_id ON processing_tasks(celery_task_id);
```

---

### **第二部分：API 接口定义**

所有接口都遵循 RESTful 风格，并使用 JWT (JSON Web Token) 进行认证。

#### **模块一：认证模块**

**1. 用户注册**
*   **接口**: `POST /auth/register`
*   **描述**: 创建一个新用户账户。
*   **请求体**:
    ```json
    {
        "username": "newuser",
        "email": "user@example.com",
        "password": "a-strong-password"
    }
    ```
*   **成功响应 (201)**:
    ```json
    {
        "id": "uuid",
        "username": "newuser",
        "email": "user@example.com",
        "storage_quota_bytes": 5368709120,
        "storage_used_bytes": 0
    }
    ```

**2. 用户登录**
*   **接口**: `POST /auth/login`
*   **描述**: 验证用户凭据并返回 JWT。
*   **请求体**:
    ```json
    {
        "email": "user@example.com",
        "password": "a-strong-password"
    }
    ```
*   **成功响应 (200)**:
    ```json
    {
        "access_token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9...",
        "token_type": "bearer",
        "expires_in": 3600
    }
    ```

**3. 获取当前用户信息**
*   **接口**: `GET /auth/me`
*   **描述**: 获取当前登录用户的详细信息。
*   **认证**: 需要 JWT (`Authorization: Bearer <token>`)
*   **成功响应 (200)**: 返回与注册成功后相同的用户信息。

---

#### **模块二：用户文件管理**

**1. 文件上传**
*   **接口**: `POST /files/upload`
*   **描述**: 上传一个或多个文件。
*   **认证**: 需要 JWT
*   **请求体**: `multipart/form-data`
    *   `files`: 文件数组
*   **成功响应 (201)**:
    ```json
    {
        "files": [
            {
                "id": "uuid",
                "original_filename": "video.mp4",
                "file_size_bytes": 104857600,
                "status": "active"
            }
        ]
    }
    ```

**2. 获取文件列表**
*   **接口**: `GET /files`
*   **描述**: 获取当前用户的文件列表，支持分页和筛选。
*   **认证**: 需要 JWT
*   **查询参数**: `?page=1&size=20&status=active`
*   **成功响应 (200)**:
    ```json
    {
        "items": [
            { "id": "uuid", "original_filename": "video.mp4", "status": "completed", ... }
        ],
        "total": 50,
        "page": 1,
        "size": 20
    }
    ```

**3. 下载文件**
*   **接口**: `GET /files/{file_id}/download`
*   **描述**: 下载指定的文件。
*   **认证**: 需要 JWT
*   **安全检查**: 必须验证 `file_id` 是否属于当前用户。
*   **成功响应 (200)**: 直接返回文件的二进制流。

**4. 删除文件**
*   **接口**: `DELETE /files/{file_id}`
*   **描述**: 将文件标记为“待删除”（软删除），进入宽限期。
*   **认证**: 需要 JWT
*   **成功响应 (204)**: No Content

**5. 恢复文件**
*   **接口**: `POST /files/{file_id}/restore`
*   **描述**: 将一个“待删除”的文件恢复为“活跃”状态。
*   **认证**: 需要 JWT
*   **成功响应 (200)**: 返回更新后的文件对象。

**6. 置顶/取消置顶文件**
*   **接口**: `POST /files/{file_id}/pin`
*   **描述**: 切换文件的置顶状态，被置顶的文件不会被自动清理。
*   **认证**: 需要 JWT
*   **成功响应 (200)**: 返回更新后的文件对象。

---

#### **模块三：处理任务模块**

**1. 创建处理任务**
*   **接口**: `POST /tasks/process`
*   **描述**: 提交一个新的 FFmpeg 处理任务。
*   **认证**: 需要 JWT
*   **请求体**:
    ```json
    {
        "source_file_ids": ["uuid1", "uuid2"],
        "output_filename": "merged-output.mp4",
        "operations": [
            { "type": "trim", "fileIndex": 0, "startTime": 10, "endTime": 60 },
            { "type": "transcode", "settings": { "videoCodec": "libx264", "bitrate": "2000k" } },
            { "type": "merge", "fileIndices": [0, 1] }
        ]
    }
    ```
*   **成功响应 (202)**:
    ```json
    {
        "task_id": "uuid"
    }
    ```

**2. 查询任务状态**
*   **接口**: `GET /tasks/{task_id}/status`
*   **描述**: 获取任务的实时状态和进度。
*   **认证**: 需要 JWT
*   **成功响应 (200)**:
    ```json
    {
        "id": "uuid",
        "status": "running",
        "progress": 45,
        "result_file_id": null,
        "error_message": null
    }
    ```

**3. 取消任务**
*   **接口**: `POST /tasks/{task_id}/cancel`
*   **描述**: 取消一个正在运行或等待中的任务。
*   **认证**: 需要 JWT
*   **成功响应 (200)**: 返回更新后的任务对象，状态为 `cancelled`。

---

这份文档涵盖了后端开发所需的核心数据结构和 API 接口。在实际开发中，你还需要考虑错误处理、输入验证、日志记录和更完善的单元测试。